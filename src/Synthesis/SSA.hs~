-- src/Synthesis/SSA.hs
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections   #-}

-- | *Passo SSA* – insere nós `InstIncTag` em arestas que fazem retro-fluxo
--   (back-edges) dentro de componentes fortemente conexas, garantindo uma
--   forma Single-Static-Assignment para loops.
module SSA (ssaTransform) where

----------------------------------------------------------------------
-- Imports
----------------------------------------------------------------------
import           Types
import           Node
import           Unique                    ( Unique, evalUnique, freshId )

import qualified Data.Map.Strict           as Map
import           Data.Graph                ( SCC(..), stronglyConnComp )
import           Control.Monad.State.Strict

----------------------------------------------------------------------
-- API
----------------------------------------------------------------------
-- | Transforma o grafo, adicionando ‘InstIncTag’ onde necessário.
ssaTransform :: DGraph DNode -> DGraph DNode
ssaTransform g@DGraph{..}
  | null backEdges = g
  | otherwise      = evalUnique $ execStateT (mapM_ insertInc backEdges) g
  where
    ------------------------------------------------------------------
    -- 1. Mapa NodeId → SCC
    ------------------------------------------------------------------
    sccMap :: Map.Map NodeId (Map.Map NodeId ())
    sccMap = nodeToScc g

    ------------------------------------------------------------------
    -- 2. Seleciona arestas internas a SCCs não triviais
    ------------------------------------------------------------------
    backEdges :: [Edge]
    backEdges =
      [ e
      | e@(s, _, d, _) <- dgEdges
      , let ms = Map.lookup s sccMap
            md = Map.lookup d sccMap
      , Just cs <- [ms]    -- Maybe → lista
      , Just cd <- [md]
      , cs == cd           -- mesma SCC
      , s /= d             -- descarta laços próprios
      , Map.size cs > 1    -- SCC com >1 nó (existe ciclo)
      ]

----------------------------------------------------------------------
-- Inserção do ‘InstIncTag’
----------------------------------------------------------------------
type M = StateT (DGraph DNode) Unique

insertInc :: Edge -> M ()
insertInc (src, sp, dst, dp) = do
  nid <- freshId
  let tagNode = InstIncTag nid src
      e1 = (src, sp,  nid, "in")
      e2 = (nid, "out", dst, dp)
  modify' $ \g@DGraph{..} ->
    g { dgNodes = Map.insert nid tagNode dgNodes
      , dgEdges = e1 : e2 : filter (/= (src, sp, dst, dp)) dgEdges
      }

----------------------------------------------------------------------
-- Utilitário: constrói mapa NodeId ↦ SCC (conjunto de nós)
----------------------------------------------------------------------
nodeToScc :: DGraph DNode -> Map.Map NodeId (Map.Map NodeId ())
nodeToScc DGraph{..} = Map.fromList pairs
  where
    -- Lista (vertex, key, sucessores)
    vertices = [ (nId n, nId n, succs (nId n)) | n <- Map.elems dgNodes ]
    succs v  = [ d | (s, _, d, _) <- dgEdges, s == v ]

    comps  = stronglyConnComp vertices

    pairs  = concatMap sccPairs comps

    sccPairs (AcyclicSCC v)   = [(v, Map.singleton v ())]
    sccPairs (CyclicSCC vs)   =
      let set = Map.fromList (map (,()) vs)
      in  [ (v, set) | v <- vs ]
