{-# LANGUAGE OverloadedStrings #-}

-- |
-- Module      : Main
-- Description : CLI to extract super-instructions and emit a Supers.hs module.
-- Maintainer  : ricardofilhoschool@gmail.com
-- Stability   : experimental
-- Portability : portable
--
-- This executable is used only to generate a Haskell module (Supers.hs)
-- containing FFI-exported super entry points. It does:
--
--   1. Read a .hsk program (from file or STDIN)
--   2. Lex/parse it into a Program
--   3. Assign stable names s1, s2, ... to all Super nodes
--   4. Collect all supers as SuperSpec records
--   5. Emit a Supers.hs module on stdout
--
-- NOTE: We deliberately DO NOT run Semantic.checkAll here. The bodies of
--       supers may reference names (like 'sum', 'map', etc.) that are not
--       visible to our small language. Type/scope errors in those bodies
--       are left for GHC to report when compiling Supers.hs.

module Main where

import System.Environment (getArgs)
import System.Exit        (exitFailure)
import System.IO          (hPutStrLn, stderr, readFile, getContents)
import System.FilePath    (takeBaseName)

import Analysis.Lexer     (alexScanTokens)
import Analysis.Parser    (parse)
import Syntax             (Program)
import Semantic           (assignSuperNames)

import Synthesis.SuperExtract (collectSupers)
import Synthesis.SupersEmit   (emitSupersModule)

main :: IO ()
main = do
  args  <- getArgs
  src   <- case args of
    [file] -> readFile file
    []     -> getContents
    _      -> hPutStrLn stderr "Usage: supersgen [file]" >> exitFailure

  let prog0 :: Program
      prog0 = parse (alexScanTokens src)

      -- assign sequential names s1, s2, ... to all Super nodes
      prog  = assignSuperNames prog0

      baseName = case args of
        [file] -> takeBaseName file
        _      -> "stdin"

      specs = collectSupers prog
      hs    = emitSupersModule baseName specs

  putStr hs
