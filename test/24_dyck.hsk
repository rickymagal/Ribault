-- dyck_path.hsk
-- Dyck path validation with tunable parameters:
-- * Size (n)
-- * Parenthesis imbalance (delta)
-- * Work imbalance (imb 0-100)
-- * Number of processors (p)

-- PARAMETERS (overwritten by script)

n x     = 10000

p x     = 8

imb x   = 1

delta x = 0

-- ------------------------------------------------------------
-- Helpers (all definitions end with ')
-- ------------------------------------------------------------

len xs = case xs of
  []      -> 0

  (_:ys)  -> 1 + len ys

takeN k xs = if k <= 0 then [] else case xs of
  []     -> []

  (y:ys) -> y : takeN (k-1) ys

dropN k xs = if k <= 0 then xs else case xs of
  []     -> []

  (_:ys) -> dropN (k-1) ys

splitAtN k xs = (takeN k xs, dropN k xs)

replicateN k x = if k <= 0 then [] else x : replicateN (k-1) x

-- ------------------------------------------------------------
-- Dyck-like sequence generator with controlled imbalance
-- '(' →  1 
-- ')' → -1
-- ------------------------------------------------------------

repeatDyck m acc =
  if m == 0
  then acc
  else repeatDyck (m - 1) (1 : -1 : acc)

append xs ys = case xs of
  []     -> ys

  (h:ts) -> h : append ts ys

generateDyck len d =
  let base = repeatDyck (len / 2) [] in
  if d == 0
    then base
    else if d > 0
      then append base (replicateN d 1)
      else append base (replicateN (0 - d) (-1))

inputSeq = generateDyck (n 0) (delta 0)

-- ------------------------------------------------------------
-- SUPER: sequential processing of a chunk
-- returns (totalSum, minPrefix)
-- ------------------------------------------------------------

analyseChunk lst =
  super single input (lst) output (res)
  #BEGINSUPER
    aux s mn []     = (s, mn)
    aux s mn (x:xs) =
      let s1  = s + x in
      let mn1 = if s1 < mn then s1 else mn in
      aux s1 mn1 xs
    (tot, mn) = aux 0 0 lst
    res = [tot, mn]
  #ENDSUPER

chunkPair lst = case analyseChunk lst of
  [s, mn] -> (s, mn)

-- ------------------------------------------------------------
-- Imbalanced split controlled by IMB (work-skew)
-- IMB = 0 → 50/50 
-- IMB ≈100 → ~75/25
-- ------------------------------------------------------------

splitImb xs =
  splitAtN (((len xs) * (100 + (imb 0))) / 200) xs

-- ------------------------------------------------------------
-- Parallel recursion with SUPER grain control
-- ------------------------------------------------------------

threshold = (n 0) / (p 0)

checkRec n0 lst =
  if (len lst) <= n0
    then chunkPair lst
    else case splitImb lst of
      (lft, rgt) ->
        case checkRec n0 lft of
          (s1, m1) ->
            case checkRec n0 rgt of
              (s2, m2) ->
                ( s1 + s2
                , if m1 < (s1 + m2) then m1 else (s1 + m2) )

-- ------------------------------------------------------------
-- Final Dyck check
-- ------------------------------------------------------------

validateDyck lst =
  case checkRec threshold lst of
    (tot, mn) -> (tot == 0) && (mn >= 0)

main = validateDyck inputSeq
