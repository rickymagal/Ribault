min2 a b = if a < b then a else b;

len xs =
  case xs of
    [] -> 0;
    (h:t) -> 1 + len t
;

splitAt n xs =
  if n <= 0 then
    ([], xs)
  else
    case xs of
      [] -> ([], []);
      (h:t) ->
        let (l, r) = splitAt (n - 1) t in
        ([h] ++ l, r)
;

rep x n =
  if n <= 0 then
    []
  else
    [x] ++ rep x (n - 1)
;

mkDyck n = (rep 1 n) ++ (rep (0 - 1) n);

statsF s m xs =
  case xs of
    [] -> (s, m);
    (h:t) ->
      let s1 = s + h in
      let m1 = min2 m s1 in
      statsF s1 m1 t
;

stats xs = statsF 0 0 xs;

skew n bias =
  let k0 = (n * bias) / 100 in
  if k0 <= 0 then 1 else if k0 >= n then n - 1 else k0
;

takeN n xs =
  if n <= 0 then
    []
  else
    case xs of
      [] -> [];
      (h:t) -> [h] ++ takeN (n - 1) t
;

dropN n xs =
  if n <= 0 then
    xs
  else
    case xs of
      [] -> [];
      (h:t) -> dropN (n - 1) t
;

splitAt2 n xs = (takeN n xs, dropN n xs);

combine s1 m1 s2 m2 =
  let s = s1 + s2 in
  let m = min2 m1 (s1 + m2) in
  (s, m)
;

dyckStats xs bias n0 =
  let n = len xs in
  if n <= n0 then
    stats xs
  else
    let k = skew n bias in
    let (l, r) = splitAt2 k xs in
    let (s1, m1) = dyckStats l bias n0 in
    let (s2, m2) = dyckStats r bias n0 in
    combine s1 m1 s2 m2
;

isValid xs bias n0 =
  let (s, m) = dyckStats xs bias n0 in
  if s == 0 then (if m >= 0 then 1 else 0) else 0
;

mkInput n bias n0 = mkDyck n;

main =
  let n = 10 in
  let bias = 75 in
  let n0 = 8 in
  isValid (mkInput n bias n0) bias n0
