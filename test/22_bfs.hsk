-- Grafo de exemplo: lista de pares (vértice, lista de vizinhos)
graph = [(1,[2,3]), (2,[4]), (3,[4,5]), (4,[]), (5,[])]

-- lookupGraph: dado um grafo e um nó, retorna sua lista de vizinhos
lookupGraph g x = case g of
  []               -> []

  ((v,vs):rest)    ->
    if x == v
      then vs
      else lookupGraph rest x

-- elem: testa se x está em xs
elem x xs = case xs of
  []      -> False

  (y:ys)  ->
    if x == y
      then True
      else elem x ys

-- append: concatena duas listas
append xs ys = case xs of
  []      -> ys

  (z:zs)  -> z : append zs ys

-- filterNotVisited: mantém só os vizinhos não visitados
filterNotVisited xs visited = case xs of
  []      -> []

  (z:zs)  ->
    if elem z visited
      then filterNotVisited zs visited
      else z : filterNotVisited zs visited

-- bfsRec: (fila de nós) e (lista de visitados)
bfsRec queue visited = case queue of
  []      -> visited

  (n:ns)  ->
    let nbrs     = lookupGraph graph n in
    let news     = filterNotVisited nbrs visited in
    let queue'   = append ns news in
    let visited' = append visited news in
    bfsRec queue' visited'

-- bfs: inicia a BFS a partir de um nó
bfs start = bfsRec [start] [start]

-- main: executa bfs a partir de 1
main = bfs 1
