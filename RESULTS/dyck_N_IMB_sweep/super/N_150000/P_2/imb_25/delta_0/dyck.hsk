-- dyck_path.hsk  (index-based, unrolled tree, auto-generated)
-- N=150000  P=2  IMB=25  DELTA=0
-- 2 leaves, no recursion

-- SUPER: analyse elements [start .. start+count-1] of the Dyck sequence
-- Input:  sc = start * SHIFT + count  (packed literal)
-- Output: packed result = (tot + OFFSET) * RANGE + (mn + OFFSET)
analyseRange sc =
  super single input (sc) output (res)
#BEGINSUPER
    res =
      let
        sh     = 150001
        start  = sc `div` sh
        cnt    = sc `mod` sh
        endIdx = start + cnt
        ntot   = 150000
        d      = 0
        off    = 150000
        rng    = 300001
        gen i  = if i < ntot
                 then (if mod i 2 == 0 then 1 else -1)
                 else (if d > 0 then 1 else -1)
        go s mn i
          | i >= endIdx = (s + off) * rng + (mn + off)
          | otherwise   =
              let x   = gen i
                  s1  = s + x
                  mn1 = if s1 < mn then s1 else mn
              in s1 `seq` mn1 `seq` go s1 mn1 (i + 1)
      in go 0 0 start
#ENDSUPER

-- SUPER: compute min of two packed values
-- Input: packed = (a + MINOFF) * MINSH + (b + MINOFF)
-- Output: min(a, b)
myMin packed =
  super single input (packed) output (m)
#BEGINSUPER
    m = let minsh = 450001
            minoff = 300000
            a = packed `div` minsh - minoff
            b = packed `mod` minsh - minoff
        in if a < b then a else b
#ENDSUPER

-- SUPER: unpack final result, check validity, print
checkAndPrint packed =
  super single input (packed) output (out)
#BEGINSUPER
    out =
      let off = 150000
          rng = 300001
          tot = packed `div` rng - off
          mn  = packed `mod` rng - off
          r   = if tot == 0 then (if mn >= 0 then 1 else 0) else 0
      in unsafePerformIO (do print r; pure 0)
#ENDSUPER

-- Main: 2 parallel leaf SUPERs + merge tree
main =
  let a0 = analyseRange 93750
  in let sc1 = 93750 * 150001 + 56250
  in let a1 = analyseRange sc1
  in let s_0 = a0 / 300001 - 150000
  in let m_0 = a0 % 300001 - 150000
  in let s_1 = a1 / 300001 - 150000
  in let m_1 = a1 % 300001 - 150000
  in let ms0 = s_0 + s_1
  in let vv0 = s_0 + m_1
  in let lo0 = m_0 + 300000
  in let ls0 = lo0 * 450001
  in let vo0 = vv0 + 300000
  in let mp0 = ls0 + vo0
  in let mm0 = myMin mp0
  in let sf_off = ms0 + 150000
  in let sf_sc = sf_off * 300001
  in let mf_off = mm0 + 150000
  in let final_packed = sf_sc + mf_off
  in checkAndPrint final_packed
