-- dyck_path.hsk  (index-based, unrolled tree, auto-generated)
-- N=850000  P=4  IMB=65  DELTA=0
-- 4 leaves, no recursion

-- SUPER: analyse elements [start .. start+count-1] of the Dyck sequence
-- Input:  sc = start * SHIFT + count  (packed literal)
-- Output: packed result = (tot + OFFSET) * RANGE + (mn + OFFSET)
analyseRange sc =
  super single input (sc) output (res)
#BEGINSUPER
    res =
      let
        sh     = 850001
        start  = sc `div` sh
        cnt    = sc `mod` sh
        endIdx = start + cnt
        ntot   = 850000
        d      = 0
        off    = 850000
        rng    = 1700001
        gen i  = if i < ntot
                 then (if mod i 2 == 0 then 1 else -1)
                 else (if d > 0 then 1 else -1)
        go s mn i
          | i >= endIdx = (s + off) * rng + (mn + off)
          | otherwise   =
              let x   = gen i
                  s1  = s + x
                  mn1 = if s1 < mn then s1 else mn
              in s1 `seq` mn1 `seq` go s1 mn1 (i + 1)
      in go 0 0 start
#ENDSUPER

-- SUPER: compute min of two packed values
-- Input: packed = (a + MINOFF) * MINSH + (b + MINOFF)
-- Output: min(a, b)
myMin packed =
  super single input (packed) output (m)
#BEGINSUPER
    m = let minsh = 2550001
            minoff = 1700000
            a = packed `div` minsh - minoff
            b = packed `mod` minsh - minoff
        in if a < b then a else b
#ENDSUPER

-- SUPER: unpack final result, check validity, print
checkAndPrint packed =
  super single input (packed) output (out)
#BEGINSUPER
    out =
      let off = 850000
          rng = 1700001
          tot = packed `div` rng - off
          mn  = packed `mod` rng - off
          r   = if tot == 0 then (if mn >= 0 then 1 else 0) else 0
      in unsafePerformIO (do print r; pure 0)
#ENDSUPER

-- Main: 4 parallel leaf SUPERs + merge tree
main =
  let a0 = analyseRange 578531
  in let sc1 = 578531 * 850001 + 122719
  in let a1 = analyseRange sc1
  in let sc2 = 701250 * 850001 + 122718
  in let a2 = analyseRange sc2
  in let sc3 = 823968 * 850001 + 26032
  in let a3 = analyseRange sc3
  in let s_0 = a0 / 1700001 - 850000
  in let m_0 = a0 % 1700001 - 850000
  in let s_1 = a1 / 1700001 - 850000
  in let m_1 = a1 % 1700001 - 850000
  in let s_2 = a2 / 1700001 - 850000
  in let m_2 = a2 % 1700001 - 850000
  in let s_3 = a3 / 1700001 - 850000
  in let m_3 = a3 % 1700001 - 850000
  in let ms0 = s_0 + s_1
  in let vv0 = s_0 + m_1
  in let lo0 = m_0 + 1700000
  in let ls0 = lo0 * 2550001
  in let vo0 = vv0 + 1700000
  in let mp0 = ls0 + vo0
  in let mm0 = myMin mp0
  in let ms1 = s_2 + s_3
  in let vv1 = s_2 + m_3
  in let lo1 = m_2 + 1700000
  in let ls1 = lo1 * 2550001
  in let vo1 = vv1 + 1700000
  in let mp1 = ls1 + vo1
  in let mm1 = myMin mp1
  in let ms2 = ms0 + ms1
  in let vv2 = ms0 + mm1
  in let lo2 = mm0 + 1700000
  in let ls2 = lo2 * 2550001
  in let vo2 = vv2 + 1700000
  in let mp2 = ls2 + vo2
  in let mm2 = myMin mp2
  in let sf_off = ms2 + 850000
  in let sf_sc = sf_off * 1700001
  in let mf_off = mm2 + 850000
  in let final_packed = sf_sc + mf_off
  in checkAndPrint final_packed
