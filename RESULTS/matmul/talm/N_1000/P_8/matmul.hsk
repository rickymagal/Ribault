-- matmul.hsk  (auto-generated, Haskell supers)
-- N=1000  P=8  blocks=8

-- SUPER: multiply rows [start..start+rows) of A by B^T
-- Input: packed = start * 1001 + rows
-- Output: partial checksum (truncated integer)
block_mul packed =
  super single input (packed) output (cs)
#BEGINSUPER
    cs = let
        sh   = 1001 :: Int64
        n    = 1000 :: Int64
        s    = packed `div` sh
        rows = packed `mod` sh
        -- generate A (seed=42) and B (seed=137) deterministically
        -- simple LCG: x_{i+1} = (a*x_i + c) mod m, scaled to [0,1)
        lcg seed idx =
          let m = 2147483647 :: Int64
              a = 1103515245 :: Int64
              c = 12345 :: Int64
              val = (a * (seed + idx) + c) `mod` m
          in fromIntegral val / fromIntegral m
        getA i j = lcg 42  (i * n + j)
        getB i j = lcg 137 (i * n + j)
        dot i k = sum [ getA (s + i) j * getB k j | j <- [0..n-1] ]
        blockCS = sum [ dot ri k | ri <- [0..rows-1], k <- [0..n-1] ]
      in truncate (blockCS * 1000000 :: Double)
#ENDSUPER

-- SUPER: print final checksum
print_checksum cs =
  super single input (cs) output (out)
#BEGINSUPER
    out = unsafePerformIO
      (do
        putStrLn ("CHECKSUM=" ++ show cs)
        pure 0)
#ENDSUPER

main =
  let b0 = block_mul 125
  in let b1 = block_mul 125250
  in let b2 = block_mul 250375
  in let b3 = block_mul 375500
  in let b4 = block_mul 500625
  in let b5 = block_mul 625750
  in let b6 = block_mul 750875
  in let b7 = block_mul 876000
  in let total = b0 + b1 + b2 + b3 + b4 + b5 + b6 + b7
  in print_checksum total
